# Review 

## 2020/1/4

### 进程同步 

consumer 和 producer 进程之间同步失败的关键在于对临界资源 counter 的访问不是顺序的，而是交错的。
```asm
reg1 = counter
reg1 = reg1 + 1
counter = reg1

reg2 = counter
reg2 = reg2 + 1
counter = reg2
```
上述两段代码可以理解为 consumer 和 producer 进程的代码被编译后得到的汇编操作指令。当两段代码顺序执行时，没问题；交错执行时，出错。

解决问题的关键在于让两个进程对 counter 的访问是互斥的。任意时刻只能有一个进程能够修改临界资源。

#### 信号量

wait 和 signal 操作

wait(m)：
1. m -= 1
2. if m < 0 将自己加入 m 的等待队列，并且阻塞自己

signal(m)
1. m += 1
2. if m <= 0 weakup m 等待队列中被阻塞的进程

m 初始值为 1，表示只允许一个进程访问该资源。当 m < 0 时，说明此时有进程阻塞在 m 的等待队列中。

Simultaneous Wait：进程同时申请多个资源，S1、S2、... 、Sn。只有当 n 个资源同时申请成功时，才分配，否则一个都不分配。

应用：
1. 实现进程间的互斥
2. 实现进程之间的前驱关系

#### 管程
利用共享数据结构抽象地表示系统中的共享资源，而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request 和release。

例如在 cs6.824 中实现的 FIFO 类。

管程的实现需要使用条件变量。当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个问题，引入了条件变量 condition

### 进程通信
### 线程