
<!-- TOC -->

- [Review](#review)
  - [2020/1/10](#2020110)
    - [kubernetes Service 的负载均衡](#kubernetes-service-%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1)
  - [2020/1/9](#202019)
    - [Docker 镜像](#docker-%e9%95%9c%e5%83%8f)
      - [基本概念](#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
      - [镜像构建](#%e9%95%9c%e5%83%8f%e6%9e%84%e5%bb%ba)
  - [2020/1/4](#202014)
    - [OS](#os)
      - [进程同步](#%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5)
        - [信号量](#%e4%bf%a1%e5%8f%b7%e9%87%8f)
        - [管程](#%e7%ae%a1%e7%a8%8b)
      - [进程通信](#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1)
    - [线程](#%e7%ba%bf%e7%a8%8b)
      - [线程的实现方式](#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f)
      - [线程实现](#%e7%ba%bf%e7%a8%8b%e5%ae%9e%e7%8e%b0)

<!-- /TOC -->

# Review 

## 2020/1/10

### kubernetes Service 的负载均衡
Service的类型：Cluster IP，LoadBalance。。。

## 2020/1/9

### Docker 镜像

#### 基本概念
> 镜像分层

docker镜像本质是docker容器运行时需要使用的各种文件。文件以用户自定义的结构组织起来（最常见的方式是类似操作系统目录系统的结构）。文件的组织方式为分层结构。即利用DockerFile在一个基础镜像之上，添加新的层。

docker镜像的分层实现了在不通过镜像之间共享镜像层的效果。

分层结构是通过联合文件系统实现的。联合文件系统有多种实现。作用就是将不同文件系统下的文件挂载到同一个目录下，并且给它们赋予不同的读写权限。联合文件系统中删除只读文件夹中的文件使用的是 WhiteOut 机制。

> 写时复制

不论是制作还是通过 docker run 来使用镜像，基础镜像都是作为一个 read-only layer 使用的。容器运行和制作容器镜像的增删改等操作则都是在位于顶层的可读写层中进行的(写时复制以及WhiteOut机制)。

> 内容寻址

利用文件内容为镜像生成一个内容哈希值，用内容哈希值来索引镜像。这样对于来自不同构建的镜像层，只要拥有相同的内容，那就可以被视为相同的镜像层，可以被共享。

> 特殊的init层

init 层是 docker 使用的一个内部层，用来存放/etc/hosts，/etc/resolv.conf等内容。需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如hostname，所以就需要将这些文件放入可读写层。但是这些属性往往只想规定对当次容器运行的参数，不希望在执行docker commit之后将这些设置写入新创建的容器镜像，所以就将这些文件放入一个可读写的init层，在docker commmit时只会提交可读写层。

#### 镜像构建




## 2020/1/4
### OS
#### 进程同步 

consumer 和 producer 进程之间同步失败的关键在于对临界资源 counter 的访问不是顺序的，而是交错的。
```asm
reg1 = counter
reg1 = reg1 + 1
counter = reg1

reg2 = counter
reg2 = reg2 + 1
counter = reg2
```
上述两段代码可以理解为 consumer 和 producer 进程的代码被编译后得到的汇编操作指令。当两段代码顺序执行时，没问题；交错执行时，出错。

解决问题的关键在于让两个进程对 counter 的访问是互斥的。任意时刻只能有一个进程能够修改临界资源。

##### 信号量

wait 和 signal 操作

wait(m)：
1. m -= 1
2. if m < 0 将自己加入 m 的等待队列，并且阻塞自己

signal(m)
1. m += 1
2. if m <= 0 weakup m 等待队列中被阻塞的进程

m 初始值为 1，表示只允许一个进程访问该资源。当 m < 0 时，说明此时有进程阻塞在 m 的等待队列中。

Simultaneous Wait：进程同时申请多个资源，S1、S2、... 、Sn。只有当 n 个资源同时申请成功时，才分配，否则一个都不分配。

应用：
1. 实现进程间的互斥
2. 实现进程之间的前驱关系

##### 管程
利用共享数据结构抽象地表示系统中的共享资源，而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request 和release。

例如在 cs6.824 中实现的 FIFO 类。

管程的实现需要使用条件变量。当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个问题，引入了条件变量 condition

#### 进程通信

机制分为三大类：
1. 共享存储器系统
   1. 共享数据结构，比如生产者消费者问题中使用 buffer 
   2. 共享存储区
2. 消息传递机制
   1. 直接通信
   2. 间接通信
3. 管道通信，管道是一个共享文件

消息缓冲队列：操作系统提供的一种进程间通信手段。基于消息缓冲区。一条消息的结构
```c
type message buffer = record
    sender  :  发送者进程标识符
    size    :  消息长度 
    text    ： 正文
    next    :  指向下一个消息缓冲区队列的指针
```
操作系统同时在进程的 PCB 中设置相关的数据结构，比如指向消息队列的指针、互斥量、条件变量等来同步对消息队列的操作


### 线程

前面说了，进程是为了实现多道程序设计，让多道程序可以同时进入内存。使得多个程序能够并发执行，提高资源利用率和系统吞吐量。

传统进程作为资源分配和调度的基本单位，进程之间进行切换的代价较大。

线程是为了提供程序并发执行的程度，进一步提高系统的吞吐量。

基本思想：**将进程作为资源分配的基本单位和作为运行调度基本单位的两个属性分开。**

进程与线程的区别：
1. 调度
   线程是调度和分派的基本单元，进程是资源拥有的基本单位。同一个进程中，线程切换不会引起进程切换，不同进程之间的线程切换会引起进程切换。

2. 并发性
   多线程不会因为一个动作而阻塞整个进程

3. 资源拥有
   线程不拥有资源，但是可以访问其隶属进程的资源，包括代码段、数据段以及拥有的系统资源。
  
4. 系统开销
   线程切换开销较小。

#### 线程的实现方式

* 内核支持线程：

对于通常的进程，无论是系统进程还是用户进程，进程的创建、撤消，以及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。

操作系统对内核支持线程的控制方式与进程相同，都是在内核空间完成的，并且还为线程在内核中设置线程控制块用来控制线程的创建、终止和切换。

这种方式最主要的优点在于当进程执行引起阻塞的系统调用时，内核可以调度进程内的其他线程继续运行，不至于阻塞整个进程。

主要的缺点在于用户的线程之间进行切换需要在内核空间中完成，由用户空间切换至内核空间的开销较大。

* 用户级线程

用户级线程只存在于用户空间中，对于这种线程的创建、撤销、以及线程之间的同步和通信等功能都无需利用系统调用来实现。这种线程是与内核无关的。

对于用户级线程，其调度依然是以进程为单位的。在采用轮转调度算法时，时间片的分配是以进程为单位的，进程内的线程共同使用一个时间片，所以单个线程实际得到的时间片为 T/n

优点：
1. 与内核无关，用户级线程创建、切换等代价很低
2. 调度算法可以是进程专用的
3. 实现与系统无关，甚至可以在不支持线程的OS上实现用户级线程

主要缺点：
1. 系统调用的阻塞问题
2. 在单纯的用户线程实现中，由于内核分配给进程的只有一个CPU就导致进程内的多线程无法使用多个CPU


#### 线程实现

1. 内核支持线程

在进程 PCB 内分配一个 PTDA(Per Task Data Area)，PTDA 中保存线程的 TCB。TCB 中保存了线程运行时需要的基本信息，OS 可以从 TCB 中恢复已暂停线程的运行。所有线程的控制信息都把保存在内核空间中。

2. 用户级线程
   1. 通过运行时系统(Runtime System)。运行时系统实质上就是所有管理用户线程需要的函数的集合，运行时系统中的所有函数都运行在用户空间，作为用户级线程和操作系统的接口。
   这种线程无法直接使用系统调用，而是由运行时系统将请求转发给操作系统。
   2. 轻量级进程(Light Weight Process)。对应多对多模型。LWP可以通过系统调用来获得内核提供的服务，当用户级线程运行时，将其绑定到一个LWP上。
   **而实际使用时，由于用户线程数量庞大，可行的做法是将LWP做成一个线程池**。用户进程中的任何一个线程都可以连接到LWP池中的任何一个线程中

![](../Review/pic/2020-01-16-14-51-51.png)


1. 一对多模型
   内核线程和用户线程一对一。对内核线程的开销较大，需要限制系统的线程总数
2. 多对一模型
   多个用户线程对应一个内核线程。当用户线程需要访问内核时将它和一个内核线程连接，同一个进程内只允许一个线程进行映射。
3. 多对多模型